---
name: Maxwell Swift Expert
description: Advanced Swift patterns including meta-programming, Swift macros, code generation, Smith framework architecture, and production optimization. Provides comprehensive expertise on Swift 6.2+ features, dependency injection, and architectural decision frameworks.
tags:
  - "Smith"
  - "meta-programming"
  - "Swift macros"
  - "code generation"
  - "architecture"
  - "decision"
  - "pattern"
  - "anti-pattern"
  - "production"
  - "module boundaries"
  - "framework selection"
  - "design principles"
  - "architectural validation"
triggers:
  - "Smith"
  - "meta-programming"
  - "Swift macros"
  - "code generation"
  - "architecture"
  - "decision"
  - "pattern"
  - "anti-pattern"
  - "design"
  - "module"
  - "boundary"
  - "framework"
  - "validation"
allowed-tools:
  - Read
  - Glob
  - Grep
  - Write
  - Bash
version: "3.0.0"
author: "Claude Code Skill - Maxwell Architecture"
---

# Maxwell Swift Expert

**For:** Swift development teams implementing advanced patterns with meta-programming, Swift macros, and production optimization
**Purpose**: Advanced Swift patterns, Smith framework architecture, meta-programming, and code generation with Swift 6.2+ compliance
**Expertise**: **Advanced Swift + Smith Framework** with production-tested validation, Swift macros, and comprehensive architectural patterns
**Content:** Complete coverage of advanced Swift patterns and production optimization

## üéØ What This Skill Provides

### **Smith Framework + Meta-Programming Authority**
- **Universal Principles**: Swift 6.2+ compliance, concurrency, logging, and dependency injection standards
- **Decision Frameworks**: Quantitative thresholds for architectural choices (module creation, dependency patterns)
- **Swift Meta-Programming**: Production-tested Swift macros, code generation, and compile-time optimization
- **Production Patterns**: Battle-tested patterns from real-world applications
- **Validation Systems**: Automated compliance checking and architectural enforcement
- **Anti-Pattern Catalog**: Common mistakes and their prevention with solutions

### **Knowledge Domains Covered**

#### **Foundational Principles**
- **Swift 6.2+ Compliance**: Strict concurrency, Sendable requirements, @MainActor patterns
- **Dependency Injection**: Modern @DependencyClient patterns vs legacy approaches
- **State Management**: ObservableState, @Shared state, and coordination patterns
- **Logging Systems**: OSLog integration, structured logging, and debugging patterns
- **Access Control**: Module boundaries, API design, and dependency management

#### **Decision Frameworks**
- **Module Creation**: Quantitative criteria for when to create Swift Package modules
- **Dependency Patterns**: @DependencyClient vs Singleton decision frameworks
- **Architecture Selection**: Framework choice and integration patterns
- **Refactoring Timing**: When and how to restructure architectures
- **Design Trade-offs**: Quantitative analysis for architectural decisions

#### **Production Patterns**
- **Module Boundaries**: Clean separation between concerns with explicit interfaces
- **API Design**: Public API boundaries and transitive dependency management
- **State Coordination**: Multi-feature state synchronization patterns
- **Error Handling**: Robust error handling and recovery strategies
- **Performance Optimization**: Architectural patterns for performance

#### **Real-World Validation**
- **Case Studies**: 15+ production bug fixes with detailed analysis
- **Anti-Pattern Prevention**: Common architectural mistakes and their solutions
- **Lessons Learned**: Real-world application insights and best practices
- **Testing Strategies**: Architectural testing and validation approaches
- **Compliance Checking**: Automated validation and compliance frameworks

## üîß Knowledge Base Structure

```
knowledge/architecture/
‚îú‚îÄ‚îÄ patterns/
‚îÇ   ‚îú‚îÄ‚îÄ AGENTS-DECISION-TREES.md         # Architectural decision frameworks with quantitative criteria
‚îÇ   ‚îî‚îÄ‚îÄ AGENTS-AGNOSTIC.md               # Universal principles and foundational patterns
‚îú‚îÄ‚îÄ pointfree/                            # Point-Free ecosystem coordination patterns
‚îÇ   ‚îú‚îÄ‚îÄ decision-trees/                  # Framework selection decision trees
‚îÇ   ‚îú‚îÄ‚îÄ examples/                       # Integration examples and patterns
‚îÇ   ‚îú‚îÄ‚îÄ integration/                    # Cross-framework coordination
‚îÇ   ‚îú‚îÄ‚îÄ routing/                        # Framework detection and routing patterns
‚îÇ   ‚îú‚îÄ‚îÄ resources/                      # Validation tools and references
‚îÇ   ‚îî‚îÄ‚îÄ validation/                    # Architectural validation rules and anti-patterns
‚îî‚îÄ‚îÄ case-studies/                           # Real-world architectural case studies
    ‚îú‚îÄ‚îÄ DISCOVERY-5-ACCESS-CONTROL-CASCADE-FAILURE.md
    ‚îú‚îÄ‚îÄ DISCOVERY-14-NESTED-REDUCER-GOTCHAS.md
    ‚îú‚îÄ‚îÄ DISCOVERY-6-IFLET-CLOSURE-REQUIREMENT.md
    ‚îú‚îÄ‚îÄ DISCOVERY-8-EXCLUSIVE-STATE-INTRO-STAGES.md
    ‚îî‚îÄ‚îÄ ... (15+ additional case studies)
```

## üöÄ Key Capabilities

### **Quantitative Decision Support**
- **Module Creation Criteria**: Specific thresholds for when to create Swift Package modules
- **Dependency Decision Trees**: Framework selection logic with cost-benefit analysis
- **Architecture Metrics**: Measurable criteria for architectural quality
- **Risk Assessment**: Quantitative frameworks for architectural decisions

### **Production-Ready Patterns**
- **Module Boundary Patterns**: Clean separation with explicit interfaces
- **API Design Guidelines**: Public API design with dependency management
- **State Coordination**: Multi-feature state synchronization patterns
- **Error Handling**: Robust error handling and recovery strategies
- **Performance Patterns**: Architectural approaches for optimization

### **Validation and Compliance**
- **Automated Checking**: Script-based validation and compliance frameworks
- **Anti-Pattern Detection**: Comprehensive catalog of architectural anti-patterns
- **Code Review Standards**: Guidelines for architectural code review
- **Compliance Reporting**: Automated compliance checking and reporting

### **Real-World Validation**
- **Case Study Analysis**: 15+ production bug fixes with detailed root cause analysis
- **Lessons Learned**: Insights from real-world application development
- **Best Practices**: Production-tested patterns and recommendations
- **Anti-Pattern Prevention**: Common mistakes and their effective solutions

## üéØ Usage Examples

### **Architectural Decision Support**
```
User: "Should I extract this 1000-line reducer into a separate module?"
‚Üí Provides quantitative criteria (line count, action count, complexity metrics) and recommendation
```

### **Framework Selection**
```
User: "Should I use @DependencyClient or singleton for my API client?"
‚Üí Provides decision tree with performance, maintainability, and scalability considerations
```

### **Module Boundary Design**
```
User: "What are the best practices for module boundaries in my Swift project?"
‚Üí Provides comprehensive guidelines for clean separation with explicit interfaces
```

### **Production Validation**
```
User: "How do I validate my architecture for production deployment?"
‚Üí Provides automated compliance checking and validation frameworks
```

### **Troubleshooting Support**
```
User: "My architecture has circular dependencies - what should I do?"
‚Üí Provides case studies and anti-pattern solutions for common architectural problems
```

## üîç Knowledge Organization

### **Progressive Complexity**
- **Principles**: Fundamental Swift and architectural principles
- **Decisions**: Quantitative frameworks for making architectural choices
- **Patterns**: Practical implementation patterns and guidelines
- **Validation**: Comprehensive validation and compliance checking

### **Cross-Reference Integration**
- **TCA Integration**: Links to TCA-specific architectural considerations
- **SharePlay Integration**: Coordination with collaborative architecture patterns
- **Platform Guidance**: Platform-specific architectural patterns and optimizations

### **Real-World Examples**
- **Case Studies**: Production bug fixes with detailed analysis and solutions
- **Lessons Learned**: Insights from real architectural challenges
- **Best Practices**: Proven patterns for successful implementations

## ‚úÖ Authority and Validation

### **Smith Framework Excellence**
- **Production Tested**: All patterns validated in real-world applications
- **Comprehensive Coverage**: Complete architectural lifecycle from design to deployment
- **Quantitative Criteria**: Objective metrics for architectural decisions
- **Continuous Improvement**: Ongoing validation and refinement of patterns

### **Real-World Validation**
- **15+ Case Studies**: Detailed analysis of production issues and solutions
- **Anti-Pattern Prevention**: Comprehensive catalog of common mistakes
- **Best Practices**: Proven patterns from successful implementations
- **Performance Evidence**: Measurable improvements and optimizations

### **Standards Compliance**
- **Swift 6.2+ Ready**: Full compliance with modern Swift requirements
- **Apple Guidelines**: Consistent with Apple architectural best practices
- **Industry Standards**: Follows established software engineering principles
- **Quality Assurance**: Comprehensive testing and validation frameworks

## üéØ Getting Started

### **For Beginners**
Ask about architectural fundamentals:
- "What are the principles of good software architecture?"
- "How do I apply Smith Framework principles?"
- "What are the benefits of clean architecture?"

### **For Intermediate Users**
Ask about specific architectural challenges:
- "How do I decide when to create a new module?"
- "What are the best practices for API design?"
- "How do I handle dependencies in my architecture?"

### **For Advanced Users**
Ask about complex architectural scenarios:
- "How do I validate my architecture for scalability?"
- "What are the architectural patterns for large-scale applications?"
- "How do I refactor complex architectures with minimal risk?"

**Maxwell Swift Expert** provides the comprehensive, production-tested guidance needed for advanced Swift development with meta-programming, Smith Framework principles, and modern architectural patterns, backed by quantitative decision frameworks and real-world validation.